<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>CygneNoir</title>
    <subtitle></subtitle>
    <icon>http://example.com/assets/favicon.ico</icon>
    <link href="http://example.com" />
    <author>
      <name>CygneNoir</name>
    </author>
    <updated>2024-07-31T14:16:49.535Z</updated>
    <entry>
        <id>http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
        <content type="html"></content>
        <updated>2024-07-31T14:16:49.535Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void counting_sort()
&amp;#123;
    int sorted[N];
    int maxv = a[0];
    for (int i = 1; i &amp;lt; n; i ++ )
        if (maxv &amp;lt; a[i])
            maxv = a[i];
    int count[maxv+1];
    for (int i = 0; i &amp;lt; n; i ++ ) count[a[i]] ++ ;
    for (int i = 1; i &amp;lt;= maxv; i ++ ) count[i] += count[i-1];
    for (int i = n-1; i &amp;gt;= 0; i -- )
    &amp;#123;
        sorted[count[a[i]]-1] = a[i];
        count[a[i]] -- ;
    &amp;#125;
    for (int i = 0; i &amp;lt; n; i ++ ) a[i] = sorted[i];
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2024-07-31T14:16:49.529Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E6%A1%B6%E6%8E%92%E5%BA%8F/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
        <content type="html">&lt;h6 id=&#34;基数排序是桶排序的特例优势是可以处理浮点数和负数劣势是还要配合别的排序函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#基数排序是桶排序的特例优势是可以处理浮点数和负数劣势是还要配合别的排序函数&#34;&gt;#&lt;/a&gt; （基数排序是桶排序的特例，优势是可以处理浮点数和负数，劣势是还要配合别的排序函数）&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;int&amp;gt; bucketSort(vector&amp;lt;int&amp;gt;&amp;amp; nums) &amp;#123;
    int n = nums.size();
    int maxv = *max_element(nums.begin(), nums.end());
    int minv = *min_element(nums.begin(), nums.end());
    int bs = 1000;
    int m = (maxv-minv)/bs+1;
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; bucket(m);
    for (int i = 0; i &amp;lt; n; ++i) &amp;#123;
        bucket[(nums[i]-minv)/bs].push_back(nums[i]);
    &amp;#125;
    int idx = 0;
    for (int i = 0; i &amp;lt; m; ++i) &amp;#123;
        int sz = bucket[i].size();
        bucket[i] = quickSort(bucket[i]);
        for (int j = 0; j &amp;lt; sz; ++j) &amp;#123;
            nums[idx++] = bucket[i][j];
        &amp;#125;
    &amp;#125;
    return nums;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2024-07-31T14:16:49.523Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void insert_sort()
&amp;#123;
    for (int i = 1; i &amp;lt; n; i ++ )
    &amp;#123;
        int x = a[i];
        int j = i-1;

        while (j &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt; a[j])
        &amp;#123;
            a[j+1] = a[j];
            j -- ;
        &amp;#125;
        a[j+1] = x;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2024-07-31T14:16:49.518Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88%E6%9C%80%E5%BF%AB%EF%BC%89/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88%E6%9C%80%E5%BF%AB%EF%BC%89/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void quick_sort(int l, int r)
&amp;#123;
    if (l &amp;gt;= r) return ;

    int x = a[l+r&amp;gt;&amp;gt;1], i = l-1, j = r+1;
    while (i &amp;lt; j)
    &amp;#123;
        while (a[++ i] &amp;lt; x);
        while (a[-- j] &amp;gt; x);
        if (i &amp;lt; j) swap(a[i], a[j]);
    &amp;#125;
    sort(l, j), sort(j+1, r);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2024-07-31T14:16:49.512Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void merge_sort(int l, int r)
&amp;#123;
    if (l &amp;gt;= r) return;
    int temp[N];
    int mid = l+r&amp;gt;&amp;gt;1;
    merge_sort(l, mid), merge_sort(mid+1, r);
    int k = 0, i = l, j = mid+1;
    while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= r)
    &amp;#123;
        if (a[i] &amp;lt; a[j]) temp[k ++ ] = a[i ++ ];
        else temp[k ++ ] = a[j ++ ];

    &amp;#125;
    while (i &amp;lt;= mid) temp[k ++ ] = a[i ++ ];
    while (j &amp;lt;= r) temp[k ++ ] = a[j ++ ];
    for (int i = l, j = 0; i &amp;lt;= r; i ++ , j ++ ) a[i] = temp[j];
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2024-07-31T14:16:49.506Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void shell_sort()
&amp;#123;
    for (int gap = n &amp;gt;&amp;gt; 1; gap; gap &amp;gt;&amp;gt;= 1)
    &amp;#123;
        for (int i = gap; i &amp;lt; n; i ++ )
        &amp;#123;
            int x = a[i];
            int j;
            for (j = i; j &amp;gt;= gap &amp;amp;&amp;amp; a[j-gap] &amp;gt; x; j -= gap)
                a[j] = a[j-gap];
            a[j] = x;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2024-07-31T14:16:49.500Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
        <content type="html">&lt;p&gt;####### &lt;a href=&#34;%EF%BC%88%E9%A1%BB%E7%9F%A5%E6%AD%A4%E6%8E%92%E5%BA%8F%E4%B8%BA%E4%BD%BF%E7%94%A8%E4%BA%86%E6%A8%A1%E6%8B%9F%E5%A0%86%EF%BC%8C%E4%B8%BA%E4%BA%86%E4%BD%BF%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E7%BC%96%E5%8F%B7%E4%B8%BAn/2%EF%BC%8C%E6%95%B0%E7%BB%84%E7%BC%96%E5%8F%B7%E4%BB%8E1%E5%BC%80%E5%A7%8B%EF%BC%89&#34;&gt;（须知此排序为使用了模拟堆，为了使最后一个非叶子节点的编号为 n/2，数组编号从 1 开始）&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void down(int u)
&amp;#123;
    int t = u;
    if (u&amp;lt;&amp;lt;1 &amp;lt;= n &amp;amp;&amp;amp; h[u&amp;lt;&amp;lt;1] &amp;lt; h[t]) t = u&amp;lt;&amp;lt;1;
    if ((u&amp;lt;&amp;lt;1|1) &amp;lt;= n &amp;amp;&amp;amp; h[u&amp;lt;&amp;lt;1|1] &amp;lt; h[t]) t = u&amp;lt;&amp;lt;1|1;
    if (u != t)
    &amp;#123;
        swap(h[u], h[t]);
        down(t);
    &amp;#125;
&amp;#125;

int main()
&amp;#123;
    for (int i = 1; i &amp;lt;= n; i ++ ) cin &amp;gt;&amp;gt; h[i];
    for (int i = n/2; i; i -- ) down(i);
    while (true)
    &amp;#123;
        if (!n) break;
        cout &amp;lt;&amp;lt; h[1] &amp;lt;&amp;lt; &#39; &#39;;
        h[1] = h[n];
        n -- ;
        down(1);
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2024-07-31T14:16:49.493Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int maxbit()
&amp;#123;
    int maxv = a[0];
    for (int i = 1; i &amp;lt; n; i ++ )
        if (maxv &amp;lt; a[i])
            maxv = a[i];
    int cnt = 1;
    while (maxv &amp;gt;= 10) maxv /= 10, cnt ++ ;

    return cnt;
&amp;#125;
void radixsort()
&amp;#123;
    int t = maxbit();
    int radix = 1;

    for (int i = 1; i &amp;lt;= t; i ++ )
    &amp;#123;
        for (int j = 0; j &amp;lt; 10; j ++ ) count[j] = 0;
        for (int j = 0; j &amp;lt; n; j ++ )
        &amp;#123;
            int k = (a[j] / radix) % 10;
            count[k] ++ ;
        &amp;#125;
        for (int j = 1; j &amp;lt; 10; j ++ ) count[j] += count[j-1];
        for (int j = n-1; j &amp;gt;= 0; j -- )
        &amp;#123;
            int k = (a[j] / radix) % 10;
            temp[count[k]-1] = a[j];
            count[k] -- ;
        &amp;#125;
        for (int j = 0; j &amp;lt; n; j ++ ) a[j] = temp[j];
        radix *= 10;
    &amp;#125;

&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2024-07-31T14:16:49.487Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void bubble_sort()
&amp;#123;
    for (int i = n-1; i &amp;gt;= 1; i -- )
    &amp;#123;
        bool flag = true;
        for (int j = 1; j &amp;lt;= i; j ++ )
            if (a[j-1] &amp;gt; a[j])
            &amp;#123;
                swap(a[j-1], a[j]);
                flag = false;
            &amp;#125;
        if (flag) return;
    &amp;#125;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2024-07-31T14:16:49.482Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/Classification/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/Classification/"/>
        <content type="html">&lt;h3 id=&#34;十大排序算法总结&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#十大排序算法总结&#34;&gt;#&lt;/a&gt; &lt;a href=&#34;https://www.acwing.com/solution/content/26513/&#34;&gt;十大排序算法总结&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;排序算法的分类：&lt;br /&gt;
1. 插入：[[插入排序]]，折半插入，[[希尔排序]]&lt;br /&gt;
 2. 交换：[[冒泡排序]]，[[快速排序（最快）]]&lt;br /&gt;
 3. 选择：[[选择排序]]，[[堆排序]]&lt;br /&gt;
 4. 归并：[[归并排序]]（不只二路归并）&lt;br /&gt;
5. 基数：[[基数排序]]&lt;/p&gt;
</content>
        <updated>2024-07-31T14:16:49.474Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/07/31/Algorithm/Search%20&amp;%20Graph%20Theory/AcWing%20845.%20%E5%85%AB%E6%95%B0%E7%A0%81/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/2024/07/31/Algorithm/Search%20&amp;%20Graph%20Theory/AcWing%20845.%20%E5%85%AB%E6%95%B0%E7%A0%81/"/>
        <content type="html">&lt;h3 id=&#34;八数码-bfs&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#八数码-bfs&#34;&gt;#&lt;/a&gt; &lt;a href=&#34;https://www.acwing.com/problem/content/847/&#34;&gt;八数码 - BFS&lt;/a&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;![[Pasted image 20221227151816.png]]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2024-07-31T14:16:49.432Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/07/31/Algorithm/Search%20&amp;%20Graph%20Theory/AcWing%20844.%20%E8%B5%B0%E8%BF%B7%E5%AE%AB%EF%BC%88BFS%EF%BC%89/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/2024/07/31/Algorithm/Search%20&amp;%20Graph%20Theory/AcWing%20844.%20%E8%B5%B0%E8%BF%B7%E5%AE%AB%EF%BC%88BFS%EF%BC%89/"/>
        <content type="html">&lt;h3 id=&#34;走迷宫-bfs&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#走迷宫-bfs&#34;&gt;#&lt;/a&gt; &lt;a href=&#34;https://www.acwing.com/problem/content/846/&#34;&gt;走迷宫 - BFS&lt;/a&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstring&amp;gt;

using namespace std;

typedef pair&amp;lt;int, int&amp;gt; PII;

const int N = 110;

int n, m;
int g[N][N];
int d[N][N];
PII q[N * N];

int bfs()&amp;#123;
	int hh = 0, tt = 0;
	q[0] = &amp;#123;0, 0&amp;#125;;
	memset(d, -1, sizeof d);
	d[0][0] = 0;
	int dx[4] = &amp;#123;-1, 0, 1, 0&amp;#125;, dy[4] = &amp;#123;0, 1, 0, -1&amp;#125;;
	while(hh &amp;lt;= tt)&amp;#123;
	//while 队列不空
		auto t = q[hh++];
		//每一次取出来队头元素 即 t = 队头
		for(int i = 0; i &amp;lt; 4; i++)&amp;#123;
			int x = t.first + dx[i], y = t.second + dy[i];
			//沿着这个方向走
			if(x &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt; n &amp;amp;&amp;amp; y &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;lt; m &amp;amp;&amp;amp; g[x][y] == 0 &amp;amp;&amp;amp; d[x][y] == -1)&amp;#123;
				//并且在边界内的话                      并且是空地可以走   并且没有走过的话
				//如果不是第一次搜到即走过一次了的话就不是BFS 也就不是最短距离
				//注意这里是一圈一圈搜的
				d[x][y] = d[t.first][t.second] + 1;
				q[++ tt] = &amp;#123;x, y&amp;#125;;
				//将这个点加入队列
			&amp;#125;
		&amp;#125;
	&amp;#125;
	return d[n - 1][m - 1];
	//输出右下角这个点的距离
&amp;#125;

int main()&amp;#123;
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
	for(int i = 0; i &amp;lt; n; i++)
		for(int j = 0; j &amp;lt; m; j++)
			cin &amp;gt;&amp;gt; g[i][j];
	cout &amp;lt;&amp;lt; bfs() &amp;lt;&amp;lt; endl;
	return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;![[Pasted image 20221227150900.png]]&lt;br /&gt;
![[Pasted image 20221227151607.png]]&lt;br /&gt;
![[Pasted image 20221227151454.png]]&lt;/p&gt;
&lt;h2 id=&#34;只有当所有边的权重即边权都是1的时候才可以用bfs求最短路一般情况下都要用专门的最短路算法求最短路&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#只有当所有边的权重即边权都是1的时候才可以用bfs求最短路一般情况下都要用专门的最短路算法求最短路&#34;&gt;#&lt;/a&gt; 只有当所有边的权重（即边权）都是 1 的时候才可以用 BFS 求最短路一般情况下都要用专门的最短路算法求最短路&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//dp问题可以被看成是一种特殊的最短路问题 即最短路问题是包含dp问题的 即dp问题就是没有环的最短路
//深搜可以保证可以搜到终点 但是不能保证搜到的路径是最短的

//不是所有的最短路问题都可以用bfs来做 只有当所有边的权重都一样的时候 比如说边权=1时 可以用bfs
//一般情况下都要用专门的最短路算法求最短路

//dp问题肯定不会用最短路算法来求 因为最短路算法的时间复杂度比较高 dp问题的时间复杂度比较低
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;queue&amp;gt;


using namespace std;

const int N = 110;


typedef pair&amp;lt;int, int&amp;gt; PII;

int n, m;
int g[N][N];
int d[N][N];
//如果需要记录路径 只需要记录一下哪儿个点是从哪儿个点拓展出来的就可以了
PII q[N * N], Prev[N][N];

int bfs()&amp;#123;
    int hh = 0, tt = 0;
    q[0] = &amp;#123;0, 0&amp;#125;;
    
    memset(d, -1, sizeof d);//将所有距离初始化成-1 表示没有走过
    d[0][0] = 0;//d第0初始化成0 表示已经走过了
    
    //可以用向量表示往上下左右走
    //上 (-1, 0) 右 (0, 1) 下 (1, 0) 左 (0, -1)
    
    //即  -1         0         1         0
    //        0         1         0         -1
    int dx[4] = &amp;#123;-1, 0, 1, 0&amp;#125;, dy[4] = &amp;#123;0, 1, 0, -1&amp;#125;;
    
    while(hh &amp;lt;= tt)&amp;#123;
        auto t = q[hh++];//每次取出队头
        
        for(int i = 0; i &amp;lt; 4; i++)&amp;#123;
            int x = t.first + dx[i], y = t.second + dy[i];
            if(x &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt; n &amp;amp;&amp;amp; y &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;lt; m &amp;amp;&amp;amp; g[x][y] == 0 &amp;amp;&amp;amp; d[x][y] == -1)&amp;#123;
            //这个判断的意思是 如果沿着这个边界走的话是在边界以内的 并且这个点是可以走的 即 != 0 并且这个点没有走过 即 d[x][y] == -1
                d[x][y] = d[t.first][t.second] + 1;//BFS只有第一次搜到的才是最短距离 如果不是第一次搜到那就不是最短距离
                Prev[x][y] = t;
                q[++ tt] = &amp;#123;x, y&amp;#125;;
                //新的 x 新的 y 塞进队列
            &amp;#125;
        &amp;#125;
    &amp;#125;
    
    //输出路径
    int x = n - 1, y = m - 1;
    while(x || y)&amp;#123;
        // cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; endl;
        auto t = Prev[x][y];
        x = t.first, y = t.second;
    &amp;#125;
    
    return d[n - 1][m - 1];
&amp;#125;


int main()&amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for(int i = 0; i &amp;lt; n; i++)
        for(int j = 0; j &amp;lt; m; j++)
            cin &amp;gt;&amp;gt; g[i][j];
            
    cout &amp;lt;&amp;lt; bfs() &amp;lt;&amp;lt; endl;
    
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2024-07-31T14:16:49.427Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/07/31/Algorithm/Search%20&amp;%20Graph%20Theory/AcWing%20843.%20n-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/2024/07/31/Algorithm/Search%20&amp;%20Graph%20Theory/AcWing%20843.%20n-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
        <content type="html">&lt;h3 id=&#34;n皇后问题-dfs&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#n皇后问题-dfs&#34;&gt;#&lt;/a&gt; &lt;a href=&#34;https://www.acwing.com/problem/content/845/&#34;&gt;N 皇后问题 - DFS&lt;/a&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

const int N = 20;

int n;
char g[N][N];
bool col[N], dg[N], udg[N];

void dfs(int u)&amp;#123;
	if(u == n)&amp;#123;
		for(int i = 0; i &amp;lt; n; i++) puts(g[i]);
		puts(&amp;quot;&amp;quot;);
		return;
	&amp;#125;
	for(int i = 0; i &amp;lt; n; i++)&amp;#123;
		if(!col[i] &amp;amp;&amp;amp; !dg[u + i] &amp;amp;&amp;amp; !udg[n - u + i])&amp;#123;
		//这个 偏移量 相当于 把 负数和 这个数 简单的映射了 一下
			g[u][i] = &#39;Q&#39;;
			col[i] = dg[u + i] = udg[n - u + i] = true;
			dfs(u + 1);
			col[i] = dg[u + i] = udg[n - u + i] = false;
			g[u][i] = &#39;.&#39;;
		&amp;#125;
	&amp;#125;
&amp;#125;
int main()&amp;#123;
	cin &amp;gt;&amp;gt; n;
	for(int i = 0; i &amp;lt; n; i++)
		for(int j = 0; j &amp;lt; n; j++)
			g[i][j] = &#39;.&#39;;
	dfs(0);
	return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;为什么求截距就可以判断两个点在一条对角线或者反对角线呢&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#为什么求截距就可以判断两个点在一条对角线或者反对角线呢&#34;&gt;#&lt;/a&gt; 为什么求截距就可以判断两个点在一条对角线或者反对角线呢？&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;因为b可以唯一确定一条直线，在同一条直线上面b都是相同的，所以以b为下标是可以繁殖对角线和反对角线上面放皇后的
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

const int N = 20;
int n;
char g[N][N];
bool row[N], col[N], dg[N], udg[N];

void dfs(int x, int y, int s)&amp;#123;
	if(y == n)&amp;#123;
		y = 0;
		x ++;
	&amp;#125;
	if(x == n)&amp;#123;
		if(s == n)&amp;#123;
			for(int i = 0; i &amp;lt; n; i++) puts(g[i]);
			puts(&amp;quot;&amp;quot;);
		&amp;#125;
		return;
	&amp;#125;
	//不放皇后
	dfs(x, y + 1, s);
	//放皇后
	if(!row[x] &amp;amp;&amp;amp; !col[y] &amp;amp;&amp;amp; !dg[x + y] &amp;amp;&amp;amp;!udg[x - y + n])&amp;#123;
		g[x][y] = &#39;Q&#39;;
		row[x] = col[y] = dg[x + y] = udg[x - y + n] = true;
		dfs(x, y + 1, s + 1);
		row[x] = col[y] = dg[x + y] = udg[x - y + n] = false;
		g[x][y] = &#39;.&#39;;
	&amp;#125;
&amp;#125;
int main()&amp;#123;
	cin &amp;gt;&amp;gt; n;
	for(int i = 0; i &amp;lt; n; i++)&amp;#123;
		for(int j = 0; j &amp;lt; n; j++)&amp;#123;
			g[i][j] = &#39;.&#39;;
		&amp;#125;
	&amp;#125;
	dfs(0, 0, 0);
	return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://b23.tv/EtnaOZ3&#34;&gt;懒猫老师 - C 语言 - 递归函数 - 八皇后问题 (搜索，回溯)- 哔哩哔哩&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;iframe src=&amp;quot;&lt;a href=&#34;http://player.bilibili.com/player.html?aid=76265320&amp;amp;bvid=BV1wJ411U7Gy&amp;amp;cid=130453660&amp;amp;page=1&#34;&gt;http://player.bilibili.com/player.html?aid=76265320&amp;amp;bvid=BV1wJ411U7Gy&amp;amp;cid=130453660&amp;amp;page=1&lt;/a&gt;&amp;quot; scrolling=&amp;quot;no&amp;quot; border=&amp;quot;0&amp;quot; frameborder=&amp;quot;no&amp;quot; framespacing=&amp;quot;0&amp;quot; allowfullscreen=&amp;quot;true&amp;quot; width=&amp;quot;500px&amp;quot; height=&amp;quot;500px&amp;quot;&amp;gt; &amp;lt;/iframe&amp;gt;&lt;/p&gt;
&lt;p&gt;![[Pasted image 20221225161908.png]]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//枚举方法1
// #include &amp;lt;iostream&amp;gt;

// using namespace std;

// const int N = 20;

// int n;
// char g[N][N];
// bool col[N], dg[N], udg[N];

// void dfs(int u)&amp;#123;
//     if(u == n)&amp;#123;
//         for(int i = 0;i &amp;lt; n; i++) puts(g[i]);
//         puts(&amp;quot;&amp;quot;);
//         return;
//     &amp;#125;
    
//     for(int i = 0; i &amp;lt; n; i++)
//         if(!col[i] &amp;amp;&amp;amp; !dg[u+ i] &amp;amp;&amp;amp; !udg[n - u + i])&amp;#123;//剪枝
//             g[u][i] = &#39;Q&#39;;
//             col[i] = dg[u + i] = udg[n - u + i] = true;//截距如下
//             //y = x + b                                                                                            y = -x + b
//             //b = y - x 因为 y - x 是负数，而数组下标不能为负数 所以给他加个偏移量 即 b = y - x + n                b =  y + x
//             dfs(u + 1);
//             col[i] = dg[u + i] = udg[n - u + i] = false;//恢复现场
//             g[u][i] = &#39;.&#39;;
//         &amp;#125;
// &amp;#125;

// int main()&amp;#123;
//     cin &amp;gt;&amp;gt; n;
//     for(int i = 0; i &amp;lt; n; i++)
//         for(int j = 0; j &amp;lt; n; j++)
//             g[i][j] = &#39;.&#39;;
            
//     dfs(0);
    
//     return 0;
// &amp;#125;



//枚举方法2
#include &amp;lt;iostream&amp;gt;

using namespace std;

const int N = 20;

int n;
char g[N][N];
bool row[N], col[N], dg[N], udg[N];

void dfs(int x, int y, int s)&amp;#123;
    if(y == n) y = 0, x++;
    
    if(x == n)&amp;#123;
        if(s == n)&amp;#123;
            for(int i = 0; i &amp;lt; n; i++) puts(g[i]);
            puts(&amp;quot;&amp;quot;);
        &amp;#125;
        
        return;
        //这边return下面那个dfs也会return出去到dfs下面的if去的
    &amp;#125;
    
    //不放皇后
    dfs(x, y + 1, s);
    
    //放皇后
    if(!row[x] &amp;amp;&amp;amp; !col[y] &amp;amp;&amp;amp; !dg[x + y] &amp;amp;&amp;amp; !udg[x - y + n])&amp;#123;
        g[x][y] = &#39;Q&#39;;
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = true;
        dfs(x, y + 1, s + 1);
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = false;
        g[x][y] = &#39;.&#39;;
    &amp;#125;
&amp;#125;

int main()&amp;#123;
    cin &amp;gt;&amp;gt; n;
    for(int i = 0; i &amp;lt; n; i++)
        for(int j = 0; j &amp;lt; n; j ++)
            g[i][j] = &#39;.&#39;;
            
    dfs(0, 0, 0);
    
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2024-07-31T14:16:49.422Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/07/31/Algorithm/Search%20&amp;%20Graph%20Theory/AcWing%20842.%20%E6%8E%92%E5%88%97%E6%95%B0%E5%AD%97%EF%BC%88DFS%EF%BC%89/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/2024/07/31/Algorithm/Search%20&amp;%20Graph%20Theory/AcWing%20842.%20%E6%8E%92%E5%88%97%E6%95%B0%E5%AD%97%EF%BC%88DFS%EF%BC%89/"/>
        <content type="html">&lt;h3 id=&#34;排列数字-深度优先遍历-dfs&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#排列数字-深度优先遍历-dfs&#34;&gt;#&lt;/a&gt; &lt;a href=&#34;https://www.acwing.com/problem/content/844/&#34;&gt;排列数字 - 深度优先遍历 DFS&lt;/a&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

const int N = 1e6 + 10;

int n;
int path[N];
bool st[N];

void dfs(int u)&amp;#123;
	if(u == n)&amp;#123;
		for(int i = 0; i &amp;lt; n; i++) printf(&amp;quot;%d &amp;quot;, path[i]);
		puts(&amp;quot;&amp;quot;);
		return;
	&amp;#125;
	//u &amp;lt; n
	for(int i = 1; i &amp;lt;= n; i++)&amp;#123;
		if(!st[i])&amp;#123;
			path[u] = i;
			st[i] = true;
			dfs(u + 1);
			path[u] = 0;
			st[i] = false;
		&amp;#125;
	&amp;#125;
&amp;#125;
int main()&amp;#123;
	cin &amp;gt;&amp;gt; n;
	dfs(0);
	return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;![[Pasted image 20221225142051.png]]&lt;br /&gt;
 DFS 和递归没有必要区分太开 没有必要区分它们之间的关系&lt;br /&gt;
！[[Pasted image 20221225143121.png]]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

const int N = 10;

int n;
int path[N];
bool st[N];

void dfs(int u)&amp;#123;
    if(u == n)&amp;#123;
        for(int  i = 0; i &amp;lt; n; i++) printf(&amp;quot;%d &amp;quot;, path[i]);
        
        printf(&amp;quot;\n&amp;quot;);
        return;
    &amp;#125;
    for(int i = 1; i &amp;lt;= n; i++)&amp;#123;
        if(!st[i])&amp;#123;
            path[u] = i;//将i放到当前位置上去
            st[i] = true;//记录一下这个数已经被用过了
            dfs(u + 1);//状态处理好之后递归到下一层
            
            
            //恢复现场
            // path[u] = 0;//这一段没有必要 因为递归到下一层path[u]在上面一定会被覆盖掉 所以不管是几都没问题
            st[i] = false;
        &amp;#125;
    &amp;#125;
&amp;#125;

int main()&amp;#123;
    cin &amp;gt;&amp;gt; n;
    
    dfs(0);
    
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2024-07-31T14:16:49.417Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/07/31/Algorithm/Note/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/1.8STL%E3%80%81%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97/%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0randomshuffle%E5%92%8C%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0sort/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/2024/07/31/Algorithm/Note/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/1.8STL%E3%80%81%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97/%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0randomshuffle%E5%92%8C%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0sort/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;ctime&amp;gt;//一般是可以把时间传进去当成一个随机种子

using namespace std;

// bool cmp(int a, int b)&amp;#123; //a是否应该排在b的前面
//     return a &amp;lt; b; //如果a &amp;lt; b的话 a就应该排在b的前面
// &amp;#125;


struct Rec&amp;#123;
    int x, y;
&amp;#125;a[5];
    
    
bool cmp(Rec a, Rec b)&amp;#123; //a是否应该排在b的前面
    return a.x &amp;lt; b.x; //如果a &amp;lt; b的话 a就应该排在b的前面
&amp;#125;

int main()&amp;#123;
    //int a[] = &amp;#123;1, 1, 2, 2, 3, 4&amp;#125;;
    vector&amp;lt;int&amp;gt; a(&amp;#123;1, 2, 3, 4, 5&amp;#125;);
    
    srand(time(0));//random_shuffle会用到随机种子 这个随机种子默认是0;
    
    
    random_shuffle(a.begin(), a.end());//左闭右开
    for(int x : a) cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &#39; &#39;;
    cout &amp;lt;&amp;lt; endl;
    
    sort(a.begin(), a.end(), greater&amp;lt;int&amp;gt;());//加greater&amp;lt;int&amp;gt;()参数就可以变成从大到小排序
    
    sort(a.begin(), a.end(), cmp);
    
    for(int x : a) cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &#39; &#39;;
    cout &amp;lt;&amp;lt; endl;
    
    //自己定义结构体的话是否也能排序呢
    
    
    for(int i = 0; i &amp;lt; 5; i++)&amp;#123;
        a[i].x = -i;
        a[i].y = i;
    &amp;#125;
    
    for(int i = 0; i &amp;lt; 5; i++) printf(&amp;quot;(%d, %d)&amp;quot;, a[i].x, a[i].y);
    cout &amp;lt;&amp;lt; endl;
    
    sort(a, a + 5, cmp);
    
    for(int i = 0; i &amp;lt; 5; i++) printf(&amp;quot;(%d, %d)&amp;quot;, a[i].x, a[i].y);
    cout &amp;lt;&amp;lt; endl;
    
    // sort(a, a + 5);//因为结构体是没有比较函数的所以会报错
    sort
    
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2024-07-31T14:16:49.361Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/07/31/Algorithm/Note/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/1.8STL%E3%80%81%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97/%E9%98%9F%E5%88%97/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/2024/07/31/Algorithm/Note/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/1.8STL%E3%80%81%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97/%E9%98%9F%E5%88%97/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;//这个头文件是队列的 包含两个很重要的数据结构 第一个数据结构是queue队列 第二个数据结构是priority_queue优先队列


using namespace std;

int main()&amp;#123;
    // queue&amp;lt;int&amp;gt; q;
    // queue&amp;lt;double&amp;gt; a;
    // struct Rec&amp;#123;
    //     int a, x, y;
    // &amp;#125;;
    // queue&amp;lt;Rec&amp;gt; b;
    
    
    // 队列有一个性质就是先进先出 也就是如果我们按照123的顺序去插入的话 我们得用123的顺序去排出
    
    
    //与之相对的 有一个优先队列 优先队列是如下这个方式定义的
    queue&amp;lt;int&amp;gt; q;//队列
    //默认是一个大根堆
    priority_queue&amp;lt;int&amp;gt; a;//大根堆
    //如果希望小根堆 也就是队列默认返回一个最小值 需要加两个参数
    priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; b;//小根堆
    
    
    // priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; c;//可以换成其他的类型 pair是一个双关键字的 二元组?
    
    
    // struct Rec&amp;#123;
    //     int a, b;
    //     bool operator&amp;lt; (const Rec&amp;amp; t) const&amp;#123;//重载方式这么写 一定要重载小于号因为是大根堆
    //         return a &amp;lt; t.a;//表示a越大的结构体越大
    //     &amp;#125;
    // &amp;#125;;
    // //如果要优先队列定义结构体的话一定要重载小于号
    // priority_queue&amp;lt;Rec&amp;gt; d;
    
    //默认大根堆重载小于号
    //如果用的是大根堆的话就要重载小于号 如果要用小根堆的话重载的是大于号
    
    struct Rec&amp;#123;
        int a, b;
        bool operator&amp;gt; (const Rec&amp;amp; t) const&amp;#123;
            return a &amp;gt; t.a;
        &amp;#125;
    &amp;#125;;
    priority_queue&amp;lt;Rec, vector&amp;lt;Rec&amp;gt;, greater&amp;lt;Rec&amp;gt;&amp;gt; d;
    
    d.push(&amp;#123;1, 2&amp;#125;);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2024-07-31T14:16:49.355Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/07/31/Algorithm/Note/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/1.8STL%E3%80%81%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97/%E6%A0%88/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/2024/07/31/Algorithm/Note/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/1.8STL%E3%80%81%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97/%E6%A0%88/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;stack&amp;gt;


using namespace std;


int main()&amp;#123;
    //栈 先进后出 也就是 弹出的元素 是最后一个插入的元素 123 321 队列就像是管道 栈就像是池子
    
    stack&amp;lt;int&amp;gt; stk;//栈的定义
    stk.push(1);//栈 插入一个元素
    stk.top();//返回栈顶元素
    stk.pop();//删除栈顶元素 也就是删除最后一个插入的元素
    
    //双端队列没有限制 可以从队头弹出也可以从队尾弹出
    
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2024-07-31T14:16:49.350Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/07/31/Algorithm/Note/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/1.8STL%E3%80%81%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88set%E6%9C%89%E5%BA%8F%E5%A4%9A%E9%87%8D%E9%9B%86%E5%90%88multiset/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/2024/07/31/Algorithm/Note/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/1.8STL%E3%80%81%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88set%E6%9C%89%E5%BA%8F%E5%A4%9A%E9%87%8D%E9%9B%86%E5%90%88multiset/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;set&amp;gt;//set底层实现是红黑树 set和multiset 内部实现都是相同的

using namespace std;

int main()&amp;#123;
    // set头文件里有两种不同的容器
    set&amp;lt;int&amp;gt; a;//set里不能包含重复元素 元素不能重复 如果插入重复元素的话 就会忽略掉这个操作
    multiset&amp;lt;int&amp;gt; b;//元素可以重复 这里面可以插入两个1 三个1 都是可以的
    
    
    
    
    set&amp;lt;int&amp;gt;::iterator it = a.begin();
    // it++;//++指有序序列里的下一个元素 --指有序序列里的前一个元素 --it和++it也是有的
    
    //和vector一样有end迭代器 表示迭代器最后元素的后一个位置
    a.end();
    
    a.insert(x);//表示插入一个x
    a.find(x);//指查找一个x 他会返回值等于x的一个迭代器 如果没找到x的话 他的值会返回a.end();
    //所以我们可以根据这个判断x是否在a里面存在
    
    // if(a.find(x) == a.end())//判断x在a中是否存在 但是一般判断不这么写 会用后面一个函数
    
    a.lower_bound(x);
    //找到大于等于x的最小的元素迭代器
    a.upper_bound(x);
    //找到大于x的最小的元素迭代器 注意！！！是大于 不是小于 不要用字面意思理解
    
    a.erase(it);//指把it的所有迭代器全部删掉
    
    a.count(x);//表示的是x在a里面的个数//因为set里面不能重复 如果重复会忽略所以如果x存在返回1 如果x不存在返回0 返回个数草泥马小伙子误人子弟啊
    
    //当然也可以定义一个结构体 用结构体定义一个set
    //因为set里面是需要做比较的，所以我们也是需要去重载一个小于号的
    struct Rec&amp;#123;
        int x, y;
        bool operator&amp;lt; (const Rec&amp;amp; t) const&amp;#123;
            return x &amp;lt; t.x;
        &amp;#125;
    &amp;#125;;
    
    set&amp;lt;Rec&amp;gt; c;//定义结构体
    //size/empty/clear 和vector类似
    //set支持迭代器 也是支持++ --两个宇算数相关的操作 set里的++--比较复杂 其实是找有序序列的下一个元素 在一个alpha树里他是找当前点的前驱或者后继 也可以理解为找有序序列的前一个元素或者后一个元素
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2024-07-31T14:16:49.344Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2024/07/31/Algorithm/Note/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/1.8STL%E3%80%81%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E6%94%AF%E6%8C%81%E6%93%8D%E4%BD%9C/</id>
        <title></title>
        <link rel="alternate" href="http://example.com/2024/07/31/Algorithm/Note/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/1.8STL%E3%80%81%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E6%94%AF%E6%8C%81%E6%93%8D%E4%BD%9C/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;


int main()&amp;#123;
    queue&amp;lt;int&amp;gt; q;
    // 队列支持操作
    q.push(1);//插入一个元素 指在队头插入一个元素
    q.pop();//弹出队尾元素
    q.front();//返回队头
    cout &amp;lt;&amp;lt; q.back() &amp;lt;&amp;lt; endl;//返回队尾
    
    priority_queue&amp;lt;int&amp;gt; a;//大根堆 也就是优先队列
    //优先队列支持操作
    a.push(1);//插入一个数
    a.top();//取最大值
    a.pop();//删除最大值
    
    
    //！！！注意： 队列是没有clear函数的
    //！！！除了队列 优先队列 栈其他所有的stl容器都是有clear函数的 唯独这三个容器没有clear函数
    // q.clear();//这玩意儿会报错
    
    //那么没有clear如何清空队列呢？ 只要重新初始化就可以了

    q = queue&amp;lt;int&amp;gt;();//重新初始化
    
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2024-07-31T14:16:49.338Z</updated>
    </entry>
</feed>
