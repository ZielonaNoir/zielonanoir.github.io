{
    "version": "https://jsonfeed.org/version/1",
    "title": "CygneNoir",
    "subtitle": "",
    "icon": "http://example.com/assets/favicon.ico",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/08/01/Internet%20Security/24.8.1/",
            "url": "http://example.com/2024/08/01/Internet%20Security/24.8.1/",
            "title": "",
            "date_published": "2024-08-01T07:23:54.248Z",
            "content_html": "<p>YAMAHA domain == 4<br />\nANHENG WAF03 不用选 02 LOG SOURSE IP<br />\n 周四前交<br />\n南大<br />\n设备信息找一线要<br />\n设备概要<br />\n cpu 利用率内存利用率 设备科大绿</p>\n<p>时间数量统计 前 21<br />\n 工单号 remark 在最后 jun2 开始分开建议 登录失败就写内部人员。。。<br />\nvpn 时间改一下 2024-7<br />\n 堡垒机 event name [index] 填 id<br />\n 赛门铁克 log source index NATA high level catgory<br />\n 渗透测试\t&quot; 链接: <a href=\"https://pan.baidu.com/s/1EXIaH6mV3n6_xtQ9_5PYdg\">https://pan.baidu.com/s/1EXIaH6mV3n6_xtQ9_5PYdg</a><br />\n 提取码: bxnn 复制这段内容后打开百度网盘手机 App，操作更方便哦<br />\n -- 来自百度网盘超级会员 v5 的分享 &quot;</p>\n<p>确认该次登录是否为内部人员登录。</p>\n<p>mklink /J C:\\Users\\a4061\\Desktop\\Obsidian.github.io\\Github.io\\ 新建文件夹 D:\\CygneNoir\\cygnenoir.github.io\\source</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/",
            "url": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/",
            "title": "选择排序",
            "date_published": "2024-07-31T14:16:49.535Z",
            "content_html": "",
            "tags": [
                "Algorithm",
                "Algorithm, Top 10 Sorting Algorithm"
            ]
        },
        {
            "id": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/",
            "url": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/",
            "title": "计数排序",
            "date_published": "2024-07-31T14:16:49.529Z",
            "content_html": "<pre><code class=\"language-c++\">void counting_sort()\n&#123;\n    int sorted[N];\n    int maxv = a[0];\n    for (int i = 1; i &lt; n; i ++ )\n        if (maxv &lt; a[i])\n            maxv = a[i];\n    int count[maxv+1];\n    for (int i = 0; i &lt; n; i ++ ) count[a[i]] ++ ;\n    for (int i = 1; i &lt;= maxv; i ++ ) count[i] += count[i-1];\n    for (int i = n-1; i &gt;= 0; i -- )\n    &#123;\n        sorted[count[a[i]]-1] = a[i];\n        count[a[i]] -- ;\n    &#125;\n    for (int i = 0; i &lt; n; i ++ ) a[i] = sorted[i];\n&#125;\n</code></pre>\n",
            "tags": [
                "Algorithm",
                "Algorithm, Top 10 Sorting Algorithm"
            ]
        },
        {
            "id": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E6%A1%B6%E6%8E%92%E5%BA%8F/",
            "url": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E6%A1%B6%E6%8E%92%E5%BA%8F/",
            "title": "桶排序",
            "date_published": "2024-07-31T14:16:49.523Z",
            "content_html": "<h6 id=\"基数排序是桶排序的特例优势是可以处理浮点数和负数劣势是还要配合别的排序函数\"><a class=\"anchor\" href=\"#基数排序是桶排序的特例优势是可以处理浮点数和负数劣势是还要配合别的排序函数\">#</a> （基数排序是桶排序的特例，优势是可以处理浮点数和负数，劣势是还要配合别的排序函数）</h6>\n<pre><code class=\"language-c++\">vector&lt;int&gt; bucketSort(vector&lt;int&gt;&amp; nums) &#123;\n    int n = nums.size();\n    int maxv = *max_element(nums.begin(), nums.end());\n    int minv = *min_element(nums.begin(), nums.end());\n    int bs = 1000;\n    int m = (maxv-minv)/bs+1;\n    vector&lt;vector&lt;int&gt; &gt; bucket(m);\n    for (int i = 0; i &lt; n; ++i) &#123;\n        bucket[(nums[i]-minv)/bs].push_back(nums[i]);\n    &#125;\n    int idx = 0;\n    for (int i = 0; i &lt; m; ++i) &#123;\n        int sz = bucket[i].size();\n        bucket[i] = quickSort(bucket[i]);\n        for (int j = 0; j &lt; sz; ++j) &#123;\n            nums[idx++] = bucket[i][j];\n        &#125;\n    &#125;\n    return nums;\n&#125;\n\n</code></pre>\n",
            "tags": [
                "Algorithm",
                "Algorithm, Top 10 Sorting Algorithm"
            ]
        },
        {
            "id": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/",
            "url": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/",
            "title": "插入排序",
            "date_published": "2024-07-31T14:16:49.518Z",
            "content_html": "<pre><code class=\"language-c++\">void insert_sort()\n&#123;\n    for (int i = 1; i &lt; n; i ++ )\n    &#123;\n        int x = a[i];\n        int j = i-1;\n\n        while (j &gt;= 0 &amp;&amp; x &lt; a[j])\n        &#123;\n            a[j+1] = a[j];\n            j -- ;\n        &#125;\n        a[j+1] = x;\n    &#125;\n&#125;\n</code></pre>\n",
            "tags": [
                "Algorithm",
                "Algorithm, Top 10 Sorting Algorithm"
            ]
        },
        {
            "id": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88%E6%9C%80%E5%BF%AB%EF%BC%89/",
            "url": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88%E6%9C%80%E5%BF%AB%EF%BC%89/",
            "title": "快速排序（最快）",
            "date_published": "2024-07-31T14:16:49.512Z",
            "content_html": "<pre><code class=\"language-c++\">void quick_sort(int l, int r)\n&#123;\n    if (l &gt;= r) return ;\n\n    int x = a[l+r&gt;&gt;1], i = l-1, j = r+1;\n    while (i &lt; j)\n    &#123;\n        while (a[++ i] &lt; x);\n        while (a[-- j] &gt; x);\n        if (i &lt; j) swap(a[i], a[j]);\n    &#125;\n    sort(l, j), sort(j+1, r);\n&#125;\n</code></pre>\n",
            "tags": [
                "Algorithm",
                "Algorithm, Top 10 Sorting Algorithm"
            ]
        },
        {
            "id": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/",
            "url": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/",
            "title": "归并排序",
            "date_published": "2024-07-31T14:16:49.506Z",
            "content_html": "<pre><code class=\"language-c++\">void merge_sort(int l, int r)\n&#123;\n    if (l &gt;= r) return;\n    int temp[N];\n    int mid = l+r&gt;&gt;1;\n    merge_sort(l, mid), merge_sort(mid+1, r);\n    int k = 0, i = l, j = mid+1;\n    while (i &lt;= mid &amp;&amp; j &lt;= r)\n    &#123;\n        if (a[i] &lt; a[j]) temp[k ++ ] = a[i ++ ];\n        else temp[k ++ ] = a[j ++ ];\n\n    &#125;\n    while (i &lt;= mid) temp[k ++ ] = a[i ++ ];\n    while (j &lt;= r) temp[k ++ ] = a[j ++ ];\n    for (int i = l, j = 0; i &lt;= r; i ++ , j ++ ) a[i] = temp[j];\n&#125;\n</code></pre>\n",
            "tags": [
                "Algorithm",
                "Algorithm, Top 10 Sorting Algorithm"
            ]
        },
        {
            "id": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/",
            "url": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/",
            "title": "希尔排序",
            "date_published": "2024-07-31T14:16:49.500Z",
            "content_html": "<pre><code class=\"language-c++\">void shell_sort()\n&#123;\n    for (int gap = n &gt;&gt; 1; gap; gap &gt;&gt;= 1)\n    &#123;\n        for (int i = gap; i &lt; n; i ++ )\n        &#123;\n            int x = a[i];\n            int j;\n            for (j = i; j &gt;= gap &amp;&amp; a[j-gap] &gt; x; j -= gap)\n                a[j] = a[j-gap];\n            a[j] = x;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n",
            "tags": [
                "Algorithm",
                "Algorithm, Top 10 Sorting Algorithm"
            ]
        },
        {
            "id": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%A0%86%E6%8E%92%E5%BA%8F/",
            "url": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%A0%86%E6%8E%92%E5%BA%8F/",
            "title": "堆排序",
            "date_published": "2024-07-31T14:16:49.493Z",
            "content_html": "<p>（须知此排序为使用了模拟堆，为了使最后一个非叶子节点的编号为 n/2，数组编号从 1 开始)</p>\n<pre><code class=\"language-c++\">void down(int u)\n&#123;\n    int t = u;\n    if (u&lt;&lt;1 &lt;= n &amp;&amp; h[u&lt;&lt;1] &lt; h[t]) t = u&lt;&lt;1;\n    if ((u&lt;&lt;1|1) &lt;= n &amp;&amp; h[u&lt;&lt;1|1] &lt; h[t]) t = u&lt;&lt;1|1;\n    if (u != t)\n    &#123;\n        swap(h[u], h[t]);\n        down(t);\n    &#125;\n&#125;\n\nint main()\n&#123;\n    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; h[i];\n    for (int i = n/2; i; i -- ) down(i);\n    while (true)\n    &#123;\n        if (!n) break;\n        cout &lt;&lt; h[1] &lt;&lt; ' ';\n        h[1] = h[n];\n        n -- ;\n        down(1);\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": [
                "Algorithm",
                "Algorithm, Top 10 Sorting Algorithm"
            ]
        },
        {
            "id": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/",
            "url": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/",
            "title": "基数排序",
            "date_published": "2024-07-31T14:16:49.487Z",
            "content_html": "<pre><code class=\"language-c++\">int maxbit()\n&#123;\n    int maxv = a[0];\n    for (int i = 1; i &lt; n; i ++ )\n        if (maxv &lt; a[i])\n            maxv = a[i];\n    int cnt = 1;\n    while (maxv &gt;= 10) maxv /= 10, cnt ++ ;\n\n    return cnt;\n&#125;\nvoid radixsort()\n&#123;\n    int t = maxbit();\n    int radix = 1;\n\n    for (int i = 1; i &lt;= t; i ++ )\n    &#123;\n        for (int j = 0; j &lt; 10; j ++ ) count[j] = 0;\n        for (int j = 0; j &lt; n; j ++ )\n        &#123;\n            int k = (a[j] / radix) % 10;\n            count[k] ++ ;\n        &#125;\n        for (int j = 1; j &lt; 10; j ++ ) count[j] += count[j-1];\n        for (int j = n-1; j &gt;= 0; j -- )\n        &#123;\n            int k = (a[j] / radix) % 10;\n            temp[count[k]-1] = a[j];\n            count[k] -- ;\n        &#125;\n        for (int j = 0; j &lt; n; j ++ ) a[j] = temp[j];\n        radix *= 10;\n    &#125;\n\n&#125;\n</code></pre>\n",
            "tags": [
                "Algorithm",
                "Algorithm, Top 10 Sorting Algorithm"
            ]
        },
        {
            "id": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/",
            "url": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/",
            "title": "冒泡排序",
            "date_published": "2024-07-31T14:16:49.482Z",
            "content_html": "<pre><code class=\"language-c++\">void bubble_sort()\n&#123;\n    for (int i = n-1; i &gt;= 1; i -- )\n    &#123;\n        bool flag = true;\n        for (int j = 1; j &lt;= i; j ++ )\n            if (a[j-1] &gt; a[j])\n            &#123;\n                swap(a[j-1], a[j]);\n                flag = false;\n            &#125;\n        if (flag) return;\n    &#125;\n&#125;\n\n</code></pre>\n",
            "tags": [
                "Algorithm",
                "Algorithm, Top 10 Sorting Algorithm"
            ]
        },
        {
            "id": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/Classification/",
            "url": "http://example.com/2024/07/31/Algorithm/Top%2010%20Sorting%20Algorithm/Classification/",
            "title": "十大排序算法总结",
            "date_published": "2024-07-31T14:16:49.474Z",
            "content_html": "<h3 id=\"十大排序算法总结\"><a class=\"anchor\" href=\"#十大排序算法总结\">#</a> <a href=\"https://www.acwing.com/solution/content/26513/\">十大排序算法总结</a></h3>\n<p>排序算法的分类：<br />\n1. 插入：[[插入排序]]，折半插入，[[希尔排序]]<br />\n 2. 交换：[[冒泡排序]]，[[快速排序（最快）]]<br />\n 3. 选择：[[选择排序]]，[[堆排序]]<br />\n 4. 归并：[[归并排序]]（不只二路归并）<br />\n5. 基数：[[基数排序]]</p>\n",
            "tags": [
                "Algorithm",
                "Algorithm, Top 10 Sorting Algorithm"
            ]
        },
        {
            "id": "http://example.com/2024/07/31/Algorithm/Search%20&%20Graph%20Theory/AcWing%20845.%20%E5%85%AB%E6%95%B0%E7%A0%81/",
            "url": "http://example.com/2024/07/31/Algorithm/Search%20&%20Graph%20Theory/AcWing%20845.%20%E5%85%AB%E6%95%B0%E7%A0%81/",
            "title": "AcWing 845. 八数码",
            "date_published": "2024-07-31T14:16:49.432Z",
            "content_html": "<h3 id=\"八数码-bfs\"><a class=\"anchor\" href=\"#八数码-bfs\">#</a> <a href=\"https://www.acwing.com/problem/content/847/\">八数码 - BFS</a></h3>\n<pre><code class=\"language-c++\">\n</code></pre>\n<p>![[Pasted image 20221227151816.png]]</p>\n<pre><code class=\"language-c++\">\n</code></pre>\n",
            "tags": [
                "Algorithm",
                "Algorithm, Search & Graph Theory"
            ]
        },
        {
            "id": "http://example.com/2024/07/31/Algorithm/Search%20&%20Graph%20Theory/AcWing%20844.%20%E8%B5%B0%E8%BF%B7%E5%AE%AB%EF%BC%88BFS%EF%BC%89/",
            "url": "http://example.com/2024/07/31/Algorithm/Search%20&%20Graph%20Theory/AcWing%20844.%20%E8%B5%B0%E8%BF%B7%E5%AE%AB%EF%BC%88BFS%EF%BC%89/",
            "title": "AcWing 844. 走迷宫（BFS）",
            "date_published": "2024-07-31T14:16:49.427Z",
            "content_html": "<h3 id=\"走迷宫-bfs\"><a class=\"anchor\" href=\"#走迷宫-bfs\">#</a> <a href=\"https://www.acwing.com/problem/content/846/\">走迷宫 - BFS</a></h3>\n<pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N = 110;\n\nint n, m;\nint g[N][N];\nint d[N][N];\nPII q[N * N];\n\nint bfs()&#123;\n\tint hh = 0, tt = 0;\n\tq[0] = &#123;0, 0&#125;;\n\tmemset(d, -1, sizeof d);\n\td[0][0] = 0;\n\tint dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;\n\twhile(hh &lt;= tt)&#123;\n\t//while 队列不空\n\t\tauto t = q[hh++];\n\t\t//每一次取出来队头元素 即 t = 队头\n\t\tfor(int i = 0; i &lt; 4; i++)&#123;\n\t\t\tint x = t.first + dx[i], y = t.second + dy[i];\n\t\t\t//沿着这个方向走\n\t\t\tif(x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] == 0 &amp;&amp; d[x][y] == -1)&#123;\n\t\t\t\t//并且在边界内的话                      并且是空地可以走   并且没有走过的话\n\t\t\t\t//如果不是第一次搜到即走过一次了的话就不是BFS 也就不是最短距离\n\t\t\t\t//注意这里是一圈一圈搜的\n\t\t\t\td[x][y] = d[t.first][t.second] + 1;\n\t\t\t\tq[++ tt] = &#123;x, y&#125;;\n\t\t\t\t//将这个点加入队列\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\treturn d[n - 1][m - 1];\n\t//输出右下角这个点的距离\n&#125;\n\nint main()&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor(int i = 0; i &lt; n; i++)\n\t\tfor(int j = 0; j &lt; m; j++)\n\t\t\tcin &gt;&gt; g[i][j];\n\tcout &lt;&lt; bfs() &lt;&lt; endl;\n\treturn 0;\n&#125;\n</code></pre>\n<p>![[Pasted image 20221227150900.png]]<br />\n![[Pasted image 20221227151607.png]]<br />\n![[Pasted image 20221227151454.png]]</p>\n<h2 id=\"只有当所有边的权重即边权都是1的时候才可以用bfs求最短路一般情况下都要用专门的最短路算法求最短路\"><a class=\"anchor\" href=\"#只有当所有边的权重即边权都是1的时候才可以用bfs求最短路一般情况下都要用专门的最短路算法求最短路\">#</a> 只有当所有边的权重（即边权）都是 1 的时候才可以用 BFS 求最短路一般情况下都要用专门的最短路算法求最短路</h2>\n<pre><code class=\"language-c++\">//dp问题可以被看成是一种特殊的最短路问题 即最短路问题是包含dp问题的 即dp问题就是没有环的最短路\n//深搜可以保证可以搜到终点 但是不能保证搜到的路径是最短的\n\n//不是所有的最短路问题都可以用bfs来做 只有当所有边的权重都一样的时候 比如说边权=1时 可以用bfs\n//一般情况下都要用专门的最短路算法求最短路\n\n//dp问题肯定不会用最短路算法来求 因为最短路算法的时间复杂度比较高 dp问题的时间复杂度比较低\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n\n\nusing namespace std;\n\nconst int N = 110;\n\n\ntypedef pair&lt;int, int&gt; PII;\n\nint n, m;\nint g[N][N];\nint d[N][N];\n//如果需要记录路径 只需要记录一下哪儿个点是从哪儿个点拓展出来的就可以了\nPII q[N * N], Prev[N][N];\n\nint bfs()&#123;\n    int hh = 0, tt = 0;\n    q[0] = &#123;0, 0&#125;;\n    \n    memset(d, -1, sizeof d);//将所有距离初始化成-1 表示没有走过\n    d[0][0] = 0;//d第0初始化成0 表示已经走过了\n    \n    //可以用向量表示往上下左右走\n    //上 (-1, 0) 右 (0, 1) 下 (1, 0) 左 (0, -1)\n    \n    //即  -1         0         1         0\n    //        0         1         0         -1\n    int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;\n    \n    while(hh &lt;= tt)&#123;\n        auto t = q[hh++];//每次取出队头\n        \n        for(int i = 0; i &lt; 4; i++)&#123;\n            int x = t.first + dx[i], y = t.second + dy[i];\n            if(x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] == 0 &amp;&amp; d[x][y] == -1)&#123;\n            //这个判断的意思是 如果沿着这个边界走的话是在边界以内的 并且这个点是可以走的 即 != 0 并且这个点没有走过 即 d[x][y] == -1\n                d[x][y] = d[t.first][t.second] + 1;//BFS只有第一次搜到的才是最短距离 如果不是第一次搜到那就不是最短距离\n                Prev[x][y] = t;\n                q[++ tt] = &#123;x, y&#125;;\n                //新的 x 新的 y 塞进队列\n            &#125;\n        &#125;\n    &#125;\n    \n    //输出路径\n    int x = n - 1, y = m - 1;\n    while(x || y)&#123;\n        // cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl;\n        auto t = Prev[x][y];\n        x = t.first, y = t.second;\n    &#125;\n    \n    return d[n - 1][m - 1];\n&#125;\n\n\nint main()&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 0; i &lt; n; i++)\n        for(int j = 0; j &lt; m; j++)\n            cin &gt;&gt; g[i][j];\n            \n    cout &lt;&lt; bfs() &lt;&lt; endl;\n    \n    return 0;\n&#125;\n</code></pre>\n",
            "tags": [
                "Algorithm",
                "Algorithm, Search & Graph Theory"
            ]
        },
        {
            "id": "http://example.com/2024/07/31/Algorithm/Search%20&%20Graph%20Theory/AcWing%20843.%20n-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/",
            "url": "http://example.com/2024/07/31/Algorithm/Search%20&%20Graph%20Theory/AcWing%20843.%20n-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/",
            "title": "AcWing 843. n-皇后问题",
            "date_published": "2024-07-31T14:16:49.422Z",
            "content_html": "<h3 id=\"n皇后问题-dfs\"><a class=\"anchor\" href=\"#n皇后问题-dfs\">#</a> <a href=\"https://www.acwing.com/problem/content/845/\">N 皇后问题 - DFS</a></h3>\n<pre><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N = 20;\n\nint n;\nchar g[N][N];\nbool col[N], dg[N], udg[N];\n\nvoid dfs(int u)&#123;\n\tif(u == n)&#123;\n\t\tfor(int i = 0; i &lt; n; i++) puts(g[i]);\n\t\tputs(&quot;&quot;);\n\t\treturn;\n\t&#125;\n\tfor(int i = 0; i &lt; n; i++)&#123;\n\t\tif(!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i])&#123;\n\t\t//这个 偏移量 相当于 把 负数和 这个数 简单的映射了 一下\n\t\t\tg[u][i] = 'Q';\n\t\t\tcol[i] = dg[u + i] = udg[n - u + i] = true;\n\t\t\tdfs(u + 1);\n\t\t\tcol[i] = dg[u + i] = udg[n - u + i] = false;\n\t\t\tg[u][i] = '.';\n\t\t&#125;\n\t&#125;\n&#125;\nint main()&#123;\n\tcin &gt;&gt; n;\n\tfor(int i = 0; i &lt; n; i++)\n\t\tfor(int j = 0; j &lt; n; j++)\n\t\t\tg[i][j] = '.';\n\tdfs(0);\n\treturn 0;\n&#125;\n</code></pre>\n<h3 id=\"为什么求截距就可以判断两个点在一条对角线或者反对角线呢\"><a class=\"anchor\" href=\"#为什么求截距就可以判断两个点在一条对角线或者反对角线呢\">#</a> 为什么求截距就可以判断两个点在一条对角线或者反对角线呢？</h3>\n<pre><code>因为b可以唯一确定一条直线，在同一条直线上面b都是相同的，所以以b为下标是可以繁殖对角线和反对角线上面放皇后的\n</code></pre>\n<pre><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N = 20;\nint n;\nchar g[N][N];\nbool row[N], col[N], dg[N], udg[N];\n\nvoid dfs(int x, int y, int s)&#123;\n\tif(y == n)&#123;\n\t\ty = 0;\n\t\tx ++;\n\t&#125;\n\tif(x == n)&#123;\n\t\tif(s == n)&#123;\n\t\t\tfor(int i = 0; i &lt; n; i++) puts(g[i]);\n\t\t\tputs(&quot;&quot;);\n\t\t&#125;\n\t\treturn;\n\t&#125;\n\t//不放皇后\n\tdfs(x, y + 1, s);\n\t//放皇后\n\tif(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp;!udg[x - y + n])&#123;\n\t\tg[x][y] = 'Q';\n\t\trow[x] = col[y] = dg[x + y] = udg[x - y + n] = true;\n\t\tdfs(x, y + 1, s + 1);\n\t\trow[x] = col[y] = dg[x + y] = udg[x - y + n] = false;\n\t\tg[x][y] = '.';\n\t&#125;\n&#125;\nint main()&#123;\n\tcin &gt;&gt; n;\n\tfor(int i = 0; i &lt; n; i++)&#123;\n\t\tfor(int j = 0; j &lt; n; j++)&#123;\n\t\t\tg[i][j] = '.';\n\t\t&#125;\n\t&#125;\n\tdfs(0, 0, 0);\n\treturn 0;\n&#125;\n</code></pre>\n<p><a href=\"https://b23.tv/EtnaOZ3\">懒猫老师 - C 语言 - 递归函数 - 八皇后问题 (搜索，回溯)- 哔哩哔哩</a></p>\n<p>&lt;iframe src=&quot;<a href=\"http://player.bilibili.com/player.html?aid=76265320&amp;bvid=BV1wJ411U7Gy&amp;cid=130453660&amp;page=1\">http://player.bilibili.com/player.html?aid=76265320&amp;bvid=BV1wJ411U7Gy&amp;cid=130453660&amp;page=1</a>&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; width=&quot;500px&quot; height=&quot;500px&quot;&gt; &lt;/iframe&gt;</p>\n<p>![[Pasted image 20221225161908.png]]</p>\n<pre><code class=\"language-c++\">//枚举方法1\n// #include &lt;iostream&gt;\n\n// using namespace std;\n\n// const int N = 20;\n\n// int n;\n// char g[N][N];\n// bool col[N], dg[N], udg[N];\n\n// void dfs(int u)&#123;\n//     if(u == n)&#123;\n//         for(int i = 0;i &lt; n; i++) puts(g[i]);\n//         puts(&quot;&quot;);\n//         return;\n//     &#125;\n    \n//     for(int i = 0; i &lt; n; i++)\n//         if(!col[i] &amp;&amp; !dg[u+ i] &amp;&amp; !udg[n - u + i])&#123;//剪枝\n//             g[u][i] = 'Q';\n//             col[i] = dg[u + i] = udg[n - u + i] = true;//截距如下\n//             //y = x + b                                                                                            y = -x + b\n//             //b = y - x 因为 y - x 是负数，而数组下标不能为负数 所以给他加个偏移量 即 b = y - x + n                b =  y + x\n//             dfs(u + 1);\n//             col[i] = dg[u + i] = udg[n - u + i] = false;//恢复现场\n//             g[u][i] = '.';\n//         &#125;\n// &#125;\n\n// int main()&#123;\n//     cin &gt;&gt; n;\n//     for(int i = 0; i &lt; n; i++)\n//         for(int j = 0; j &lt; n; j++)\n//             g[i][j] = '.';\n            \n//     dfs(0);\n    \n//     return 0;\n// &#125;\n\n\n\n//枚举方法2\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N = 20;\n\nint n;\nchar g[N][N];\nbool row[N], col[N], dg[N], udg[N];\n\nvoid dfs(int x, int y, int s)&#123;\n    if(y == n) y = 0, x++;\n    \n    if(x == n)&#123;\n        if(s == n)&#123;\n            for(int i = 0; i &lt; n; i++) puts(g[i]);\n            puts(&quot;&quot;);\n        &#125;\n        \n        return;\n        //这边return下面那个dfs也会return出去到dfs下面的if去的\n    &#125;\n    \n    //不放皇后\n    dfs(x, y + 1, s);\n    \n    //放皇后\n    if(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n])&#123;\n        g[x][y] = 'Q';\n        row[x] = col[y] = dg[x + y] = udg[x - y + n] = true;\n        dfs(x, y + 1, s + 1);\n        row[x] = col[y] = dg[x + y] = udg[x - y + n] = false;\n        g[x][y] = '.';\n    &#125;\n&#125;\n\nint main()&#123;\n    cin &gt;&gt; n;\n    for(int i = 0; i &lt; n; i++)\n        for(int j = 0; j &lt; n; j ++)\n            g[i][j] = '.';\n            \n    dfs(0, 0, 0);\n    \n    return 0;\n&#125;\n</code></pre>\n",
            "tags": [
                "Algorithm",
                "Algorithm, Search & Graph Theory"
            ]
        },
        {
            "id": "http://example.com/2024/07/31/Algorithm/Search%20&%20Graph%20Theory/AcWing%20842.%20%E6%8E%92%E5%88%97%E6%95%B0%E5%AD%97%EF%BC%88DFS%EF%BC%89/",
            "url": "http://example.com/2024/07/31/Algorithm/Search%20&%20Graph%20Theory/AcWing%20842.%20%E6%8E%92%E5%88%97%E6%95%B0%E5%AD%97%EF%BC%88DFS%EF%BC%89/",
            "title": "AcWing 842. 排列数字（DFS）",
            "date_published": "2024-07-31T14:16:49.417Z",
            "content_html": "<h3 id=\"排列数字-深度优先遍历-dfs\"><a class=\"anchor\" href=\"#排列数字-深度优先遍历-dfs\">#</a> <a href=\"https://www.acwing.com/problem/content/844/\">排列数字 - 深度优先遍历 DFS</a></h3>\n<pre><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N = 1e6 + 10;\n\nint n;\nint path[N];\nbool st[N];\n\nvoid dfs(int u)&#123;\n\tif(u == n)&#123;\n\t\tfor(int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, path[i]);\n\t\tputs(&quot;&quot;);\n\t\treturn;\n\t&#125;\n\t//u &lt; n\n\tfor(int i = 1; i &lt;= n; i++)&#123;\n\t\tif(!st[i])&#123;\n\t\t\tpath[u] = i;\n\t\t\tst[i] = true;\n\t\t\tdfs(u + 1);\n\t\t\tpath[u] = 0;\n\t\t\tst[i] = false;\n\t\t&#125;\n\t&#125;\n&#125;\nint main()&#123;\n\tcin &gt;&gt; n;\n\tdfs(0);\n\treturn 0;\n&#125;\n</code></pre>\n<p>![[Pasted image 20221225142051.png]]<br />\n DFS 和递归没有必要区分太开 没有必要区分它们之间的关系<br />\n！[[Pasted image 20221225143121.png]]</p>\n<pre><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N = 10;\n\nint n;\nint path[N];\nbool st[N];\n\nvoid dfs(int u)&#123;\n    if(u == n)&#123;\n        for(int  i = 0; i &lt; n; i++) printf(&quot;%d &quot;, path[i]);\n        \n        printf(&quot;\\n&quot;);\n        return;\n    &#125;\n    for(int i = 1; i &lt;= n; i++)&#123;\n        if(!st[i])&#123;\n            path[u] = i;//将i放到当前位置上去\n            st[i] = true;//记录一下这个数已经被用过了\n            dfs(u + 1);//状态处理好之后递归到下一层\n            \n            \n            //恢复现场\n            // path[u] = 0;//这一段没有必要 因为递归到下一层path[u]在上面一定会被覆盖掉 所以不管是几都没问题\n            st[i] = false;\n        &#125;\n    &#125;\n&#125;\n\nint main()&#123;\n    cin &gt;&gt; n;\n    \n    dfs(0);\n    \n    return 0;\n&#125;\n</code></pre>\n",
            "tags": [
                "Algorithm",
                "Algorithm, Search & Graph Theory"
            ]
        },
        {
            "id": "http://example.com/2024/07/31/Algorithm/Note/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/1.8STL%E3%80%81%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97/%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0randomshuffle%E5%92%8C%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0sort/",
            "url": "http://example.com/2024/07/31/Algorithm/Note/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/1.8STL%E3%80%81%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97/%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0randomshuffle%E5%92%8C%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0sort/",
            "title": "随机函数randomshuffle和排序函数sort",
            "date_published": "2024-07-31T14:16:49.361Z",
            "content_html": "<pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;ctime&gt;//一般是可以把时间传进去当成一个随机种子\n\nusing namespace std;\n\n// bool cmp(int a, int b)&#123; //a是否应该排在b的前面\n//     return a &lt; b; //如果a &lt; b的话 a就应该排在b的前面\n// &#125;\n\n\nstruct Rec&#123;\n    int x, y;\n&#125;a[5];\n    \n    \nbool cmp(Rec a, Rec b)&#123; //a是否应该排在b的前面\n    return a.x &lt; b.x; //如果a &lt; b的话 a就应该排在b的前面\n&#125;\n\nint main()&#123;\n    //int a[] = &#123;1, 1, 2, 2, 3, 4&#125;;\n    vector&lt;int&gt; a(&#123;1, 2, 3, 4, 5&#125;);\n    \n    srand(time(0));//random_shuffle会用到随机种子 这个随机种子默认是0;\n    \n    \n    random_shuffle(a.begin(), a.end());//左闭右开\n    for(int x : a) cout &lt;&lt; x &lt;&lt; ' ';\n    cout &lt;&lt; endl;\n    \n    sort(a.begin(), a.end(), greater&lt;int&gt;());//加greater&lt;int&gt;()参数就可以变成从大到小排序\n    \n    sort(a.begin(), a.end(), cmp);\n    \n    for(int x : a) cout &lt;&lt; x &lt;&lt; ' ';\n    cout &lt;&lt; endl;\n    \n    //自己定义结构体的话是否也能排序呢\n    \n    \n    for(int i = 0; i &lt; 5; i++)&#123;\n        a[i].x = -i;\n        a[i].y = i;\n    &#125;\n    \n    for(int i = 0; i &lt; 5; i++) printf(&quot;(%d, %d)&quot;, a[i].x, a[i].y);\n    cout &lt;&lt; endl;\n    \n    sort(a, a + 5, cmp);\n    \n    for(int i = 0; i &lt; 5; i++) printf(&quot;(%d, %d)&quot;, a[i].x, a[i].y);\n    cout &lt;&lt; endl;\n    \n    // sort(a, a + 5);//因为结构体是没有比较函数的所以会报错\n    sort\n    \n    return 0;\n&#125;\n</code></pre>\n",
            "tags": [
                "Algorithm",
                "Note",
                "语法基础课",
                "1.8STL、常用库函数、位运算"
            ]
        },
        {
            "id": "http://example.com/2024/07/31/Algorithm/Note/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/1.8STL%E3%80%81%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97/%E9%98%9F%E5%88%97/",
            "url": "http://example.com/2024/07/31/Algorithm/Note/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/1.8STL%E3%80%81%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97/%E9%98%9F%E5%88%97/",
            "title": "队列",
            "date_published": "2024-07-31T14:16:49.355Z",
            "content_html": "<pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;//这个头文件是队列的 包含两个很重要的数据结构 第一个数据结构是queue队列 第二个数据结构是priority_queue优先队列\n\n\nusing namespace std;\n\nint main()&#123;\n    // queue&lt;int&gt; q;\n    // queue&lt;double&gt; a;\n    // struct Rec&#123;\n    //     int a, x, y;\n    // &#125;;\n    // queue&lt;Rec&gt; b;\n    \n    \n    // 队列有一个性质就是先进先出 也就是如果我们按照123的顺序去插入的话 我们得用123的顺序去排出\n    \n    \n    //与之相对的 有一个优先队列 优先队列是如下这个方式定义的\n    queue&lt;int&gt; q;//队列\n    //默认是一个大根堆\n    priority_queue&lt;int&gt; a;//大根堆\n    //如果希望小根堆 也就是队列默认返回一个最小值 需要加两个参数\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; b;//小根堆\n    \n    \n    // priority_queue&lt;pair&lt;int, int&gt;&gt; c;//可以换成其他的类型 pair是一个双关键字的 二元组?\n    \n    \n    // struct Rec&#123;\n    //     int a, b;\n    //     bool operator&lt; (const Rec&amp; t) const&#123;//重载方式这么写 一定要重载小于号因为是大根堆\n    //         return a &lt; t.a;//表示a越大的结构体越大\n    //     &#125;\n    // &#125;;\n    // //如果要优先队列定义结构体的话一定要重载小于号\n    // priority_queue&lt;Rec&gt; d;\n    \n    //默认大根堆重载小于号\n    //如果用的是大根堆的话就要重载小于号 如果要用小根堆的话重载的是大于号\n    \n    struct Rec&#123;\n        int a, b;\n        bool operator&gt; (const Rec&amp; t) const&#123;\n            return a &gt; t.a;\n        &#125;\n    &#125;;\n    priority_queue&lt;Rec, vector&lt;Rec&gt;, greater&lt;Rec&gt;&gt; d;\n    \n    d.push(&#123;1, 2&#125;);\n&#125;\n</code></pre>\n",
            "tags": [
                "Algorithm",
                "Note",
                "语法基础课",
                "1.8STL、常用库函数、位运算"
            ]
        },
        {
            "id": "http://example.com/2024/07/31/Algorithm/Note/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/1.8STL%E3%80%81%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97/%E6%A0%88/",
            "url": "http://example.com/2024/07/31/Algorithm/Note/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/1.8STL%E3%80%81%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97/%E6%A0%88/",
            "title": "栈",
            "date_published": "2024-07-31T14:16:49.350Z",
            "content_html": "<pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;stack&gt;\n\n\nusing namespace std;\n\n\nint main()&#123;\n    //栈 先进后出 也就是 弹出的元素 是最后一个插入的元素 123 321 队列就像是管道 栈就像是池子\n    \n    stack&lt;int&gt; stk;//栈的定义\n    stk.push(1);//栈 插入一个元素\n    stk.top();//返回栈顶元素\n    stk.pop();//删除栈顶元素 也就是删除最后一个插入的元素\n    \n    //双端队列没有限制 可以从队头弹出也可以从队尾弹出\n    \n    return 0;\n&#125;\n</code></pre>\n",
            "tags": [
                "Algorithm",
                "Note",
                "语法基础课",
                "1.8STL、常用库函数、位运算"
            ]
        },
        {
            "id": "http://example.com/2024/07/31/Algorithm/Note/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/1.8STL%E3%80%81%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88set%E6%9C%89%E5%BA%8F%E5%A4%9A%E9%87%8D%E9%9B%86%E5%90%88multiset/",
            "url": "http://example.com/2024/07/31/Algorithm/Note/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/1.8STL%E3%80%81%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88set%E6%9C%89%E5%BA%8F%E5%A4%9A%E9%87%8D%E9%9B%86%E5%90%88multiset/",
            "title": "有序集合set有序多重集合multiset",
            "date_published": "2024-07-31T14:16:49.344Z",
            "content_html": "<pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;//set底层实现是红黑树 set和multiset 内部实现都是相同的\n\nusing namespace std;\n\nint main()&#123;\n    // set头文件里有两种不同的容器\n    set&lt;int&gt; a;//set里不能包含重复元素 元素不能重复 如果插入重复元素的话 就会忽略掉这个操作\n    multiset&lt;int&gt; b;//元素可以重复 这里面可以插入两个1 三个1 都是可以的\n    \n    \n    \n    \n    set&lt;int&gt;::iterator it = a.begin();\n    // it++;//++指有序序列里的下一个元素 --指有序序列里的前一个元素 --it和++it也是有的\n    \n    //和vector一样有end迭代器 表示迭代器最后元素的后一个位置\n    a.end();\n    \n    a.insert(x);//表示插入一个x\n    a.find(x);//指查找一个x 他会返回值等于x的一个迭代器 如果没找到x的话 他的值会返回a.end();\n    //所以我们可以根据这个判断x是否在a里面存在\n    \n    // if(a.find(x) == a.end())//判断x在a中是否存在 但是一般判断不这么写 会用后面一个函数\n    \n    a.lower_bound(x);\n    //找到大于等于x的最小的元素迭代器\n    a.upper_bound(x);\n    //找到大于x的最小的元素迭代器 注意！！！是大于 不是小于 不要用字面意思理解\n    \n    a.erase(it);//指把it的所有迭代器全部删掉\n    \n    a.count(x);//表示的是x在a里面的个数//因为set里面不能重复 如果重复会忽略所以如果x存在返回1 如果x不存在返回0 返回个数草泥马小伙子误人子弟啊\n    \n    //当然也可以定义一个结构体 用结构体定义一个set\n    //因为set里面是需要做比较的，所以我们也是需要去重载一个小于号的\n    struct Rec&#123;\n        int x, y;\n        bool operator&lt; (const Rec&amp; t) const&#123;\n            return x &lt; t.x;\n        &#125;\n    &#125;;\n    \n    set&lt;Rec&gt; c;//定义结构体\n    //size/empty/clear 和vector类似\n    //set支持迭代器 也是支持++ --两个宇算数相关的操作 set里的++--比较复杂 其实是找有序序列的下一个元素 在一个alpha树里他是找当前点的前驱或者后继 也可以理解为找有序序列的前一个元素或者后一个元素\n&#125;\n</code></pre>\n",
            "tags": [
                "Algorithm",
                "Note",
                "语法基础课",
                "1.8STL、常用库函数、位运算"
            ]
        }
    ]
}